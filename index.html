<table style="border-collapse: collapse; width: 42.3944%;" border="1">
<tbody>
<tr style="height: 140px;">
<td style="width: 100%; height: 140px;">
<h3>&nbsp;&nbsp;<span style="color: #ff0000;">MANISH KUMAR&nbsp;</span></h3>
<h3>&nbsp;&nbsp;<span style="color: #ff0000;">RA1811029010026</span></h3>
<h4>&nbsp;&nbsp;<span style="color: #ff0000;">CSE-CN (L2 - section)</span></h4>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h1><span style="text-decoration: underline;">DESIGN AND ANALYSIS OF ALGORITHMS</span></h1>
<p><span style="text-decoration: underline;"><img src="https://www.cdn.geeksforgeeks.org/wp-content/uploads/Competitive-Programming-1.jpg" alt="Top 10 Algorithms and Data Structures for Competitive Programming ..." width="751" height="469" /></span></p>
<p><span style="text-decoration: underline;">TOPICS TO BE COVERED:</span></p>
<p>I Design Techniques;<br />II Searching;<br />III Prioritizing;<br />IV Graph Algorithms;<br />V Topological Algorithms;<br />VI Geometric Algorithms;<br />VII NP-completeness.</p>
<h2><span style="text-decoration: underline;"><strong><span style="background-color: #ffff00;">I Design Techniques&nbsp;</span></strong></span></h2>
<p>1.Divide-and-Conquer</p>
<p>2.Dynamic Programming</p>
<p>3.Greedy Algorithm</p>
<p><span style="color: #ff0000;">1.Divide-and-Conquer:</span></p>
<p>&nbsp; &nbsp;We use quicksort as an example for an algorithm that follows the divide-and-conquer paradigm. It has the reputation of being the fasted comparison-based sorting algorithm. Indeed it is very fast on the average but can be slow<br />&nbsp; &nbsp;for some input, unless precautions are taken.</p>
<p><span style="text-decoration: underline; background-color: #ff6600;"><em><strong>The algorithm.</strong></em></span>&nbsp;Quicksort follows the general paradigm<br />of divide-and-conquer, which means it divides the unsorted array into two, it recurses on the two pieces, and it<br />finally combines the two sorted pieces to obtain the sorted<br />array. An interesting feature of quicksort is that the divide<br />step separates small from large items. As a consequence,<br />combining the sorted pieces happens automatically without doing anything extra.</p>
<p><br />void QUICKSORT(int ℓ, r)<br />if ℓ &lt; r then m = SPLIT(ℓ, r);<br />QUICKSORT(ℓ, m &minus; 1);<br />QUICKSORT(m + 1, r)<br />endif.</p>
<p><br />We assume the items are stored in A[0..n &minus; 1]. The array<br />is sorted by calling QUICKSORT(0, n &minus; 1).</p>
<p>Splitting. The performance of quicksort depends heavily on the performance of the split operation. The effect of<br />splitting from ℓ to r is:<br />&bull; x = A[ℓ] is moved to its correct location at A[m];<br />&bull; no item in A[ℓ..m &minus; 1] is larger than x;<br />&bull; no item in A[m + 1..r] is smaller than x.</p>
<p>int SPLIT(int ℓ, r)<br />x = A[ℓ]; i = ℓ; j = r + 1;<br />repeat repeat i++ until x &le; A[i];<br />repeat j-- until x &ge; A[j];<br />if i &lt; j then SWAP(i, j) endif<br />until i &ge; j;<br />SWAP(ℓ, j); return j</p>
<p><img src="https://i1.wp.com/gaebster.ch/wp-content/uploads/2018/10/quicksort.png?fit=577%2C410&amp;ssl=1" alt="Quicksort algorithm | Sortingalgorithms | Gabriel Weibel Blog" width="381" height="271" /></p>
<p><span style="text-decoration: underline; color: #ff0000;"><em><strong>2. Dynamic Programming:</strong></em></span></p>
<p><span style="color: #000000;">We illustrate dynamic programming using the edit distance problem, which is motivated by questions in genetics. We assume a finite set of characters<br />or letters, &Sigma;, which we refer to as the alphabet, and we<br />consider strings or words formed by concatenating finitely<br />many characters from the alphabet. The edit distance between two words is the minimum number of letter insertions, letter deletions, and letter substitutions required to<br />transform one word to the other. For example, the edit<br />distance between FOOD and MONEY is at most four:<br />FOOD &rarr; MOOD &rarr; MOND &rarr; MONED &rarr; MONEY</span></p>
<p><span style="color: #000000;">PREFIX PROPERTY. If we remove the last column of an<br />optimal edit sequence then the remaining columns<br />represent an optimal edit sequence for the remaining<br />substrings.</span></p>
<p><span style="color: #000000;">The algorithm. If we turned this recurrence relation directly into a divide-and-conquer algorithm, we would have<br />the following recurrence for the running time:</span></p>
<p><span style="color: #000000;"><br />T (m, n) = T (m, n &minus; 1) + T (m &minus; 1, n)<br />+ T (m &minus; 1, n &minus; 1) + 1.</span></p>
<p><span style="color: #000000;"><br />The solution to this recurrence is exponential in m and n,<br />which is clearly not the way to go. Instead, let us build<br />an m + 1 times n + 1 table of possible values of E(i, j).<br />We can start by filling in the base cases, the entries in the<br />0-th row and column. To fill in any other entry, we need<br />to know the values directly to the left, directly above, and<br />both to the left and above. If we fill the table from top to<br />bottom and from left to right then whenever we reach an<br />entry, the entries it depends on are already available.</span></p>
<p><span style="color: #000000;"><br />int EDITDISTANCE(int m, n)<br />for i = 0 to m do E[i, 0] = i endfor;<br />for j = 1 to n do E[0, j] = j endfor;<br />for i = 1 to m do<br />for j = 1 to n do<br />E[i, j] = min{E[i, j &minus; 1] + 1, E[i &minus; 1, j] + 1,<br />E[i &minus; 1, j &minus; 1] + |A[i] 6= B[j]|}<br />endfor<br />endfor;<br />return E[m, n].</span></p>
<p><span style="color: #000000;"><br />Since there are (m+1)(n+1) entries in the table and each<br />takes a constant time to compute, the total running time is<br />in O(mn).</span></p>
<p><span style="color: #000000;"><em><strong>ALGORITHM and of ALTRUISTIC.</strong> </em>The shaded area highlights the<br />optimal edit sequences, which are paths from the upper left to<br />the lower right corner.<br />A L G O R I T H M<br />A L T R U I S T I C<br />A L G O R I T H M<br />A L T R U I S T I C<br />They are easily recovered by tracing the paths backward,<br />from the end to the beginning. The following algorithm<br />recovers an optimal solution that also minimizes the number of insertions and deletions. We call it with the lengths<br />of the strings as arguments, R(m, n).<br />void R(int i, j)<br />if i &gt; 0 or j &gt; 0 then<br />switch incoming arrow:<br />case ց: R(i &minus; 1, j &minus; 1); print(A[i], B[j])<br />case &darr;: R(i &minus; 1, j); print(A[i], )<br />case &rarr;: R(i, j &minus; 1); print( , B[j]).<br />endswitch<br />endif.</span></p>
<p><span style="text-decoration: underline; color: #ff6600;"><em><strong><span>3.GREEDY ALGORITHM</span></strong></em></span></p>
<p>&nbsp;</p>
<p>A&nbsp;<strong>greedy algorithm</strong>&nbsp;is a simple, intuitive algorithm that is used in optimization problems. The algorithm makes the optimal choice at each step as it attempts to find the overall optimal way to solve the entire problem. Greedy algorithms are quite successful in some problems, such as&nbsp;<a class="wiki_link" title="Huffman encoding" href="https://brilliant.org/wiki/huffman-encoding/" target="_blank" rel="noopener">Huffman encoding</a>&nbsp;which is used to compress data, or&nbsp;<a class="wiki_link" title="Dijkstra's algorithm" href="https://brilliant.org/wiki/dijkstras-short-path-finder/" target="_blank" rel="noopener">Dijkstra's algorithm</a>, which is used to find the shortest path through a graph.</p>
<p>However, in many problems, a greedy strategy does not produce an optimal solution. For example, in the animation below, the greedy algorithm seeks to find the path with the largest sum. It does this by selecting the largest available number at each step. The greedy algorithm fails to find the largest sum, however, because it makes decisions based only on the information it has at any one step, without regard to the overall problem.</p>
<p>&nbsp;</p>
<p><span class="image-caption center"><img src="https://d18l82el6cdm1i.cloudfront.net/uploads/xlck8z42EM-greedy-search-path-example.gif" srcset="https://d18l82el6cdm1i.cloudfront.net/uploads/xlck8z42EM-greedy-search-path-example.gif 1x" alt="With a goal of reaching the largest sum, at each step, the greedy algorithm will choose what appears to be the optimal immediate choice, so it will choose 12 instead of 3 at the second step and will not reach the best solution, which contains 99." /></span></p>
<div class="col col-12 col-last wiki-main-column has-sidebar">
<div id="wiki-main" data-controller="app/newsfeed:feed" data-controller-inited="true">
<div id="cmp_wiki_canonical_page_id" class="summary-container">
<div class="summary wiki-content" data-controller="app/wiki:summary,app/zoomable:images" data-cmp-url="/wiki/greedy-algorithm/" data-page-key="wiki_canonical_page" data-cmp-key="wiki_canonical_page" data-controller-inited="true">
<div id="applications" class="anchor skill-heading collapsed" data-controller="app/wiki:expandOrCollapse" data-controller-inited="true"><header class="section-header">
<h2>Applications</h2>
</header></div>
<div id="section-applications" class="section collapsed">
<div class="section-container">
<p>There are many applications of greedy algorithms. Below is a brief explanation of the greedy nature of a famous graph search algorithm, Dijkstra's algorithm.</p>
<p><strong>Dijkstra's Algorithm</strong></p>
<p><a href="https://brilliant.org/wiki/dijkstras-short-path-finder/" target="_blank" rel="nofollow noopener">Dijkstra's algorithm</a>&nbsp;is used to find the shortest path between nodes in a graph. The algorithm maintains a set of unvisited nodes and calculates a tentative distance from a given node to another. If the algorithm finds a shorter way to get to a given node, the path is updated to reflect the shorter distance. This problem has satisfactory optimization substructure since if&nbsp;<span class="katex"><span class="katex-mathml">A</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">A</span></span></span></span>&nbsp;is connected to&nbsp;<span class="katex"><span class="katex-mathml">B,</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">B</span><span class="mpunct">,</span></span></span></span>&nbsp;<span class="katex"><span class="katex-mathml">B</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">B</span></span></span></span>&nbsp;is connected to&nbsp;<span class="katex"><span class="katex-mathml">C</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">C</span></span></span></span>, and the path must go through&nbsp;<span class="katex"><span class="katex-mathml">A</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">A</span></span></span></span>&nbsp;and&nbsp;<span class="katex"><span class="katex-mathml">B</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">B</span></span></span></span>&nbsp;to get to the destination&nbsp;<span class="katex"><span class="katex-mathml">C</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">C</span></span></span></span>, then the shortest path from&nbsp;<span class="katex"><span class="katex-mathml">A</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">A</span></span></span></span>&nbsp;to&nbsp;<span class="katex"><span class="katex-mathml">B</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">B</span></span></span></span>&nbsp;and the shortest path from&nbsp;<span class="katex"><span class="katex-mathml">B</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">B</span></span></span></span>&nbsp;to&nbsp;<span class="katex"><span class="katex-mathml">C</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">C</span></span></span></span>&nbsp;must be a part of the shortest path from&nbsp;<span class="katex"><span class="katex-mathml">A</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">A</span></span></span></span>&nbsp;to&nbsp;<span class="katex"><span class="katex-mathml">C</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">C</span></span></span></span>. So the optimal answers from the subproblems do contribute to the optimal answer for the total problem. This is because the algorithm keeps track of the shortest path possible to any given node.</p>
<p><span class="image-caption center"><img style="max-width: 576px; max-height: 500px; vertical-align: middle; border: 0px; box-sizing: border-box;" src="https://d18l82el6cdm1i.cloudfront.net/uploads/X7rvS7Kbgc-dijkstra_animation.gif" srcset="https://d18l82el6cdm1i.cloudfront.net/uploads/X7rvS7Kbgc-dijkstra_animation.gif 1x" alt="Dijkstra's algorithm to find the shortest path between &lt;strong&gt;a&lt;/strong&gt; and &lt;strong&gt;b&lt;/strong&gt;. It picks the unvisited vertex with the lowest distance, calculates the distance through it to each unvisited neighbor, and updates the neighbor's distance if smaller. Mark visited (set to red) when done with neighbors." /><span class="caption">Dijkstra's algorithm to find the shortest path between&nbsp;<strong>a</strong>&nbsp;and&nbsp;<strong>b</strong>. It picks the unvisited vertex with the lowest distance, calculates the distance through it to each unvisited neighbor, and updates the neighbor's distance if smaller. Mark visited (set to red) when done with neighbors.<sup><a class="citation-link" href="https://brilliant.org/wiki/greedy-algorithm/#citation-4">[4]</a></sup></span></span></p>
<p><strong>Huffman Coding</strong></p>
<p><a href="https://brilliant.org/wiki/huffman-encoding/" target="_blank" rel="nofollow noopener">Huffman encoding</a>&nbsp;is another example of an algorithm where a greedy approach is successful. The Huffman algorithm analyzes a message and depending on the frequencies of the characters used in the message, it assigns a variable-length encoding for each symbol. A more commonly used symbol will have a shorter encoding while a rare symbol will have a longer encoding.</p>
<p>The Huffman coding algorithm takes in information about the frequencies or probabilities of a particular symbol occurring. It begins to build the prefix tree from the bottom up, starting with the two least probable symbols in the list. It takes those symbols and forms a subtree containing them, and then removes the individual symbols from the list. The algorithm sums the probabilities of elements in a subtree and adds the subtree and its probability to the list. Next, the algorithm searches the list and selects the two symbols or subtrees with the smallest probabilities. It uses those to make a new subtree, removes the original subtrees/symbols from the list, and then adds the new subtree and its combined probability to the list. This repeats until there is one tree and all elements have been added. At each subtree, the optimal encoding for each symbol is created and together composes the overall optimal encoding.</p>
<p>&nbsp;</p>
</div>
</div>
</div>
</div>
</div>
</div>
